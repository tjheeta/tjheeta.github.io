<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devops on Nothing interesting...</title>
    <link>http://tjheeta.github.io/tags/devops/</link>
    <description>Recent content in Devops on Nothing interesting...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 16 Dec 2016 05:52:00 +0000</lastBuildDate>
    
	<atom:link href="http://tjheeta.github.io/tags/devops/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dawn of the Microlith - Monoservices with Elixir</title>
      <link>http://tjheeta.github.io/2016/12/16/dawn-of-the-microlith-monoservices-microservices-with-elixir/</link>
      <pubDate>Fri, 16 Dec 2016 05:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2016/12/16/dawn-of-the-microlith-monoservices-microservices-with-elixir/</guid>
      <description>Introduction Microservices are the newest technology trend and should be approached with deliberation. There is a ludicrous amount of subject matter on it, which I&amp;rsquo;m not going to cover. The important part to understand is if they are a fit for your organization.
To measure if the architecture adds business value, it really comes down to how quickly can features be released to production and the stability / maintainability of the codebase.</description>
    </item>
    
    <item>
      <title>Picking the right framework</title>
      <link>http://tjheeta.github.io/2016/01/31/picking-the-right-framework/</link>
      <pubDate>Sun, 31 Jan 2016 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2016/01/31/picking-the-right-framework/</guid>
      <description>It has all been done before For someone starting out building applications for web/mobile/etc, it can be absurdly difficult with all the choice. Should you use Ruby? Python? Haskell? Elixir? C? Rust? Go? Erlang? Node? PHP? Java? How about frameworks? Ruby on rails? Flask? OK, perhaps choosing is too difficult. What about a nosql database? 225 and growing, so not easy. Perhaps it would be easier to figure out a deployment model between containers and paas and configuration management tools?</description>
    </item>
    
    <item>
      <title>Ansible vs Chef</title>
      <link>http://tjheeta.github.io/2015/04/15/ansible-vs-chef/</link>
      <pubDate>Wed, 15 Apr 2015 05:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2015/04/15/ansible-vs-chef/</guid>
      <description>I wrote an earlier post about evaluating Ansible as an alternative to Chef. So after spending many years with Chef, I&amp;rsquo;ve found that Ansible is a lot easier to manage with startups. It&amp;rsquo;s easier to train developers, it&amp;rsquo;s easier to manage inventory and orchestration, and it works reasonably well on the scale of thousands of hosts. And let&amp;rsquo;s face it, if you have more than that, you&amp;rsquo;ll have to start partitioning.</description>
    </item>
    
    <item>
      <title>Ansible Credentials and Variable Overrides</title>
      <link>http://tjheeta.github.io/2015/04/14/ansible-credentials-and-variable-override/</link>
      <pubDate>Tue, 14 Apr 2015 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2015/04/14/ansible-credentials-and-variable-override/</guid>
      <description>Let&amp;rsquo;s say we need to create mysql users. We&amp;rsquo;ll be overloading at the group_vars level, with group_vars/all/mysql_users.vault.yml being overridden by the more specific group_vars/production/mysql_users.vault.yml. Although we can set some basic stuff for all the hosts in a role, we want it to be available to both the database and the app roles without introducing dependencies. Hence, group_vars/all.
In ansible, to get a merging rather than replace behaviour for hashes, we set hash_behaviour = merge in ansible.</description>
    </item>
    
    <item>
      <title>Debugging slow systems</title>
      <link>http://tjheeta.github.io/2015/03/01/debugging-systems/</link>
      <pubDate>Sun, 01 Mar 2015 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2015/03/01/debugging-systems/</guid>
      <description>Most of this post is blindingly obvious since it&amp;rsquo;s the scientific method. And quite frankly, I wouldn&amp;rsquo;t be writing it if someone didn&amp;rsquo;t ask me why something was slow. Most of the time this is a game of whack-a-mole, especially, if you don&amp;rsquo;t got something like newrelic installed. A better question to ask is not why is something slow, but when will something become slow? So let&amp;rsquo;s start with a basic, &amp;ldquo;OMG, the website is slow!</description>
    </item>
    
    <item>
      <title>Tinc VPN - setting up a mesh network</title>
      <link>http://tjheeta.github.io/2015/02/17/ansible-tinc/</link>
      <pubDate>Tue, 17 Feb 2015 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2015/02/17/ansible-tinc/</guid>
      <description>Have you ever wanted to connect up your home network, your personal servers, your laptop, and maybe some virtual machines running inside your laptop? I&amp;rsquo;ve always used OpenVPN for production networks, however, tinc is extremely convenient. It sets up a mesh between all of the members of the network. Instead of re-routing all traffic through a central server, this node to node connection decreases the latency. Tinc&amp;rsquo;s configuration is a bit painful though, so here comes a post about ansible&amp;hellip;again.</description>
    </item>
    
    <item>
      <title>Ansible autoscale (tower) alternatives</title>
      <link>http://tjheeta.github.io/2014/11/24/ansible-autoscale-tower-alternative/</link>
      <pubDate>Mon, 24 Nov 2014 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2014/11/24/ansible-autoscale-tower-alternative/</guid>
      <description>In my last post, I wanted to deploy a cluster of workers, but stopped after setting up autoscaling groups as I wanted a &amp;ldquo;nice&amp;rdquo; way to build them up. I could have plowed on with a userdata script that was built with the original master server ip, followed by using ansible-playbook to download and execute some plays. In fact, that seems awfully reasonable to me right now instead of going on this yak-shaving adventure.</description>
    </item>
    
    <item>
      <title>Ansible and EC2</title>
      <link>http://tjheeta.github.io/2014/11/21/ansible-and-ec2-part-1/</link>
      <pubDate>Fri, 21 Nov 2014 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2014/11/21/ansible-and-ec2-part-1/</guid>
      <description>There are a few must-haves to switch from Chef to Ansible and a few nice to haves.
 A replacement for chef search Ability to create and manage auto-scaling infrastructure on EC2. A way to bootstrap inventory without a central master.  So a basic application pattern would be a central server and a set of workers. To provision on EC2, we need to do a few things:
 Create a security group Spin up a central server instance Spin up worker instances Ability to setup autoscale groups Provision the workers brought up by the autoscale group  Setting up the EC2 resources is easier in ansible than in chef.</description>
    </item>
    
    <item>
      <title>Chef, Puppet, Ansible</title>
      <link>http://tjheeta.github.io/2014/11/20/chef-puppet-ansible/</link>
      <pubDate>Thu, 20 Nov 2014 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2014/11/20/chef-puppet-ansible/</guid>
      <description>I&amp;rsquo;ve been using Chef for years. Since it was in 0.7 and very rough. Before Chef, I was using Puppet. Before Puppet, there was shell scripts.
I switched from Puppet for a few reasons (I&amp;rsquo;m not sure if they apply anymore though):
 In 2009, we built our own private cloud on some blades and at the time there was no nice way to create hosts automatically. But then knife came along and we fell in love with it.</description>
    </item>
    
    <item>
      <title>Chef EC2 Autoscale</title>
      <link>http://tjheeta.github.io/2014/11/19/chef-ec2-autoscale/</link>
      <pubDate>Wed, 19 Nov 2014 04:52:00 +0000</pubDate>
      
      <guid>http://tjheeta.github.io/2014/11/19/chef-ec2-autoscale/</guid>
      <description>This post is essentially just for comparison of how to do the same autoscale with ansible as with chef.
To use chef with an autoscale group, we need to setup the chef-client with the validation key to connect back to the chef-server. Before IAM policies, we would have to do this directly in the userdata script - either by pulling it or writing our passwords there. Now with the IAM group, we can give read-only access to the ec2 instances to an s3 bucket.</description>
    </item>
    
  </channel>
</rss>